#!/bin/sh
#
# Drill down through $PATH to look for files or directories.
# Like the ksh builtin whence, except it does not stop
# after finding the first instance.  Handles spaces in both
# filenames and directories on $PATH.  Also, shell patterns
# are supported.

usage () {
  printf 'Usage: digpath [-q] [-x] file1 file2 ...\n'       >&2
  printf '       digpath [-q] [-x] shell_pattern\n'         >&2
  printf '       digpath [-h]\n\n'                          >&2
  printf 'Output: print any matches on $PATH to stdout,\n'  >&2
  printf '        suppresses output if -q given,\n'         >&2
  printf '        suppresses nonexecutables if -x given,\n' >&2
  printf '        print help to stderr if -h given\n\n'     >&2
  printf 'Exit Status: 0 (true) if match found on $PATH\n'  >&2
  printf '             1 (false) if no match found\n'       >&2
  printf '             2 -h or --help option was given\n'   >&2
}

quite_flag=
executable_flag=
while getopts :hqx opt
do
  case $opt in
    q) quite_flag=1
       ;;
    x) executable_flag=1
       ;;
    h) usage
       exit 2
       ;;
    ?) printf 'Error: invalid option %s\n' "$OPTARG"  >&2
       usage
       exit 2
       ;;
  esac
done

IFS=':'

ii=0  # for simulated array
for File in "$@"
do
   test -z "$File" && continue
   for Dir in $PATH
   do
      test ! -d "$Dir" && continue
      for target in $Dir/$File
      do
          if test -f "$target"
          then
              if test -z "$executable_flag" -o -x "$target"
              then
                  # simulating an array of found files
                  ii=$((ii + 1))
                  eval File_$ii=\"\$target\"
              fi
          fi
      done
   done
done

if test -z "$quite_flag"
then
    jj=0
    while test $jj -lt $ii
    do
        jj=$((jj+1))
        eval printf \'%s\\n\' \"\$File_$jj\"
    done
fi

if test $ii -gt 0
then
    exit 0
else
    exit 1
fi
